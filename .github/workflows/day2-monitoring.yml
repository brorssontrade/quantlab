name: Day 2 Production Monitoring

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
          - production
          - staging
        default: 'production'

jobs:
  day2-checks:
    # CRITICAL: Must run on Viktor's local Windows machine where uvicorn runs
    # All 4 labels MUST match: self-hosted + Windows + X64 + quantlab-local
    # If job queues forever: verify runner has ALL these labels in GitHub Settings → Actions → Runners
    runs-on: [self-hosted, Windows, X64, quantlab-local]
    timeout-minutes: 15
    # Force UTF-8 encoding for Python to avoid UnicodeEncodeError on Windows cp1252 console
    env:
      PYTHONUTF8: "1"
      PYTHONIOENCODING: "utf-8"
    defaults:
      run:
        shell: pwsh
    
    steps:
      - name: Runner Identity Check (MUST be self-hosted Windows)
        shell: pwsh
        run: |
          Write-Host "========================================"
          Write-Host "        RUNNER IDENTITY CHECK           "
          Write-Host "========================================"
          Write-Host ""
          Write-Host "RUNNER_NAME:        $env:RUNNER_NAME"
          Write-Host "RUNNER_OS:          $env:RUNNER_OS"
          Write-Host "RUNNER_ARCH:        $env:RUNNER_ARCH"
          Write-Host "RUNNER_ENVIRONMENT: $env:RUNNER_ENVIRONMENT"
          Write-Host "RUNNER_WORKSPACE:   $env:RUNNER_WORKSPACE"
          Write-Host ""
          Write-Host "Hostname:           $(hostname)"
          Write-Host "Username:           $(whoami)"
          
          $currentPath = (Get-Location).Path
          Write-Host "PWD:                $currentPath"
          Write-Host ""
          
          # HARD FAIL 1: Check RUNNER_OS
          if ($env:RUNNER_OS -ne "Windows") {
            Write-Host "::error::=============================================="
            Write-Host "::error::FATAL: Running on WRONG runner!"
            Write-Host "::error::=============================================="
            Write-Host "::error::Expected: Windows self-hosted runner"
            Write-Host "::error::Got:      $env:RUNNER_OS ($env:RUNNER_NAME)"
            Write-Host "::error::"
            Write-Host "::error::This workflow MUST run on Viktor's local Windows machine"
            Write-Host "::error::where uvicorn serves 127.0.0.1:8000."
            Write-Host "::error::=============================================="
            exit 1
          }
          
          # HARD FAIL 2: Check path is Windows-style (C:\...)
          if (-not ($currentPath -match "^[A-Za-z]:\\")) {
            Write-Host "::error::=============================================="
            Write-Host "::error::FATAL: Working directory is NOT a Windows path!"
            Write-Host "::error::=============================================="
            Write-Host "::error::Expected: C:\... (Windows path)"
            Write-Host "::error::Got:      $currentPath"
            Write-Host "::error::"
            Write-Host "::error::This indicates the job landed on a Linux/Mac runner."
            Write-Host "::error::=============================================="
            exit 1
          }
          
          Write-Host "✓ Running on Windows self-hosted runner"
          Write-Host "✓ Working directory is Windows path"
          Write-Host ""
          
          # Check if port 8000 has a listener
          Write-Host "Checking if port 8000 has a listener..."
          $portCheck = netstat -ano | Select-String ":8000"
          if ($portCheck) {
            Write-Host "✓ Port 8000 listeners found:"
            $portCheck | ForEach-Object { Write-Host "  $_" }
          } else {
            Write-Host "::warning::No listener found on port 8000!"
            Write-Host "::warning::uvicorn may not be running. Start it with:"
            Write-Host "::warning::  uvicorn app.main:app --host 127.0.0.1 --port 8000"
          }
          Write-Host ""
          Write-Host "========================================"

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: main
      
      - name: Setup Python environment (venv + editable install)
        run: |
          Write-Host "========================================"
          Write-Host "      PYTHON ENVIRONMENT SETUP          "
          Write-Host "========================================"
          
          # Define venv python path explicitly (avoids activation issues between steps)
          $venvPython = Join-Path $PWD ".venv\Scripts\python.exe"
          $venvPip = Join-Path $PWD ".venv\Scripts\pip.exe"
          
          # Always use/create .venv for consistent environment
          if (-not (Test-Path $venvPython)) {
            Write-Host "Creating new .venv..."
            python -m venv .venv
          }
          
          Write-Host "Venv Python: $venvPython"
          Write-Host "Venv Pip: $venvPip"
          & $venvPython --version
          & $venvPip --version
          Write-Host ""
          
          # Upgrade pip, setuptools, wheel first
          Write-Host "Upgrading pip/setuptools/wheel..."
          & $venvPython -m pip install --upgrade pip setuptools wheel
          
          # Install CORE SCIENTIFIC STACK FIRST (numpy/pandas may need compatible versions)
          # Use flexible version ranges to support Python 3.12+ / 3.14
          Write-Host ""
          Write-Host "Installing core scientific stack (numpy, pandas)..."
          & $venvPip install "numpy>=1.26" "pandas>=2.0" --upgrade
          
          # Install requirements.txt (may override versions, that's OK)
          if (Test-Path "requirements.txt") {
            Write-Host ""
            Write-Host "Installing requirements.txt..."
            & $venvPip install -r requirements.txt --upgrade
          }
          
          # Install core test dependencies explicitly (ensures they're present)
          Write-Host ""
          Write-Host "Installing test dependencies..."
          & $venvPip install pytest typer rich requests --upgrade
          
          # CRITICAL: Install project in editable mode so quantkit is importable
          Write-Host ""
          Write-Host "Installing quantlab in editable mode (pip install -e .)..."
          & $venvPip install -e .
          
          # Verify no broken dependencies
          Write-Host ""
          Write-Host "Running pip check..."
          & $venvPip check
          
          # DEPENDENCY GATE: Verify ALL critical imports before pytest
          Write-Host ""
          Write-Host "======================================="
          Write-Host "       DEPENDENCY GATE                 "
          Write-Host "======================================="
          $gatePassed = $true
          
          Write-Host "Testing numpy import:"
          & $venvPython -c "import numpy; print(f'  numpy: {numpy.__version__}')"
          if ($LASTEXITCODE -ne 0) { $gatePassed = $false }
          
          Write-Host "Testing pandas import:"
          & $venvPython -c "import pandas; print(f'  pandas: {pandas.__version__}')"
          if ($LASTEXITCODE -ne 0) { $gatePassed = $false }
          
          Write-Host "Testing typer import:"
          & $venvPython -c "import typer; print(f'  typer: {typer.__version__}')"
          if ($LASTEXITCODE -ne 0) { $gatePassed = $false }
          
          Write-Host "Testing quantkit import:"
          & $venvPython -c "import quantkit; print(f'  quantkit: {quantkit.__file__}')"
          if ($LASTEXITCODE -ne 0) { $gatePassed = $false }
          
          Write-Host "Testing pytest:"
          & $venvPython -m pytest --version
          if ($LASTEXITCODE -ne 0) { $gatePassed = $false }
          
          if (-not $gatePassed) {
            Write-Host "::error::DEPENDENCY GATE FAILED - one or more critical imports failed"
            exit 1
          }
          Write-Host ""
          Write-Host "[OK] All critical dependencies verified"
          
          # Show installed packages for debugging
          Write-Host ""
          Write-Host "pip list (scientific + test stack):"
          & $venvPip list | Select-String "numpy|pandas|typer|pytest|quantlab|rich"

      - name: Preflight - Check API is reachable
        env:
          PROD_API_BASE_URL: ${{ secrets.PROD_API_BASE_URL }}
          STAGING_API_BASE_URL: ${{ secrets.STAGING_API_BASE_URL }}
          PROD_BASE_URL: ${{ secrets.PROD_BASE_URL }}
          STAGING_BASE_URL: ${{ secrets.STAGING_BASE_URL }}
        run: |
          # Determine target URL (same priority as day2_check.py)
          $targetUrl = $null
          $source = $null
          
          if ($env:PROD_API_BASE_URL) {
            $targetUrl = $env:PROD_API_BASE_URL
            $source = "PROD_API_BASE_URL"
          } elseif ($env:STAGING_API_BASE_URL) {
            $targetUrl = $env:STAGING_API_BASE_URL
            $source = "STAGING_API_BASE_URL"
          } elseif ($env:PROD_BASE_URL) {
            $targetUrl = $env:PROD_BASE_URL
            $source = "PROD_BASE_URL"
          } elseif ($env:STAGING_BASE_URL) {
            $targetUrl = $env:STAGING_BASE_URL
            $source = "STAGING_BASE_URL"
          }
          
          if (-not $targetUrl) {
            Write-Host "::error::No API URL secret configured"
            Write-Host "::error::Set PROD_API_BASE_URL or PROD_BASE_URL in GitHub Secrets"
            exit 1
          }
          
          Write-Host "Preflight: Using $source = $targetUrl"
          Write-Host "Preflight: Checking $targetUrl/health ..."
          try {
            $response = Invoke-WebRequest -Uri "$targetUrl/health" -TimeoutSec 10 -UseBasicParsing
            Write-Host "✓ API is reachable: $($response.StatusCode)"
          } catch {
            Write-Host "::error::API not reachable at $targetUrl/health"
            Write-Host "::error::Ensure uvicorn is running: uvicorn app.main:app --host 127.0.0.1 --port 8000"
            Write-Host "::error::Error: $_"
            exit 1
          }

      - name: Run Day 2 checks
        env:
          PROD_API_BASE_URL: ${{ secrets.PROD_API_BASE_URL }}
          STAGING_API_BASE_URL: ${{ secrets.STAGING_API_BASE_URL }}
          PROD_BASE_URL: ${{ secrets.PROD_BASE_URL }}
          STAGING_BASE_URL: ${{ secrets.STAGING_BASE_URL }}
          PYTHONPATH: ${{ github.workspace }}
          GITHUB_WORKSPACE: ${{ github.workspace }}
        run: |
          Write-Host "========================================"
          Write-Host "        WORKSPACE DIAGNOSTICS           "
          Write-Host "========================================"
          Write-Host "GITHUB_WORKSPACE: $env:GITHUB_WORKSPACE"
          Write-Host "PWD: $(Get-Location)"
          Write-Host ""
          Write-Host "Git toplevel:"
          git rev-parse --show-toplevel
          Write-Host ""
          Write-Host "Workspace root contents (excluding .venv):"
          Get-ChildItem -Path $env:GITHUB_WORKSPACE -Force | Where-Object { $_.Name -ne '.venv' } | ForEach-Object { Write-Host "  $($_.Name)" }
          Write-Host ""
          Write-Host "Tests folder check:"
          $testsPath = Join-Path $env:GITHUB_WORKSPACE "tests"
          if (Test-Path $testsPath) {
            Write-Host "[OK] tests/ folder found"
            Write-Host "Test files in tests/:"
            Get-ChildItem -Path $testsPath -Filter "*.py" -Recurse | ForEach-Object { Write-Host "  $($_.FullName)" }
          } else {
            Write-Host "[WARN] tests/ folder NOT found at $testsPath"
          }
          Write-Host ""
          Write-Host "Git tracked test files:"
          git ls-files "tests/*.py" "tests/**/*.py" | ForEach-Object { Write-Host "  $_" }
          Write-Host "========================================"
          Write-Host ""
          
          # Use explicit venv python path (activation doesn't persist between steps)
          $venvPython = Join-Path $PWD ".venv\Scripts\python.exe"
          Write-Host "Using venv Python: $venvPython"
          Write-Host ""
          
          # Bulletproof preflight: verify we're using the right interpreter
          Write-Host "========================================"
          Write-Host "     PREFLIGHT INTERPRETER CHECK        "
          Write-Host "========================================"
          & $venvPython -c "import sys; print(f'sys.executable: {sys.executable}')"
          & $venvPython -m pip -V
          & $venvPython -c "import typer; print(f'typer: {typer.__version__} from {typer.__file__}')"
          & $venvPython -m pytest --version
          Write-Host "========================================"
          Write-Host ""
          
          # Run Day2 checks with explicit venv Python
          & $venvPython scripts/monitoring/day2_check.py
      
      - name: Upload reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: day2-monitoring-reports
          path: docs/verification/DAY2_REPORT.*
          retention-days: 90
      
      - name: Commit reports to main
        if: always()
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "GitHub Actions"
          
          # Check if reports exist before trying to add
          $reports = Get-ChildItem -Path "docs/verification/DAY2_REPORT.*" -ErrorAction SilentlyContinue
          if ($reports) {
            git add -f docs/verification/DAY2_REPORT.*
            $staged = git diff --cached --name-only
            if ($staged) {
              git commit -m "docs(monitoring): add Day 2 report (production run)"
              git push origin main
            } else {
              Write-Host "No changes to commit"
            }
          } else {
            Write-Host "::warning::No DAY2_REPORT files found to commit"
          }
        continue-on-error: true
